import{_ as t,c as a,a1 as o,o as r}from"./chunks/framework.CtAjElTc.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guides/消息中间件/rabbitmq/index.md","filePath":"guides/消息中间件/rabbitmq/index.md"}'),i={name:"guides/消息中间件/rabbitmq/index.md"};function n(s,e,p,d,c,l){return r(),a("div",null,e[0]||(e[0]=[o('<h2 id="消息确认" tabindex="-1">消息确认 <a class="header-anchor" href="#消息确认" aria-label="Permalink to &quot;消息确认&quot;">​</a></h2><p>执行一个任务可能需要几秒钟的时间，您可能想知道，如果消费者启动一个长任务，并在完成之前终止，会发生什么。在我们当前的代码中，一旦RabbitMQ将消息传递给消费者，它会立即将其标记为删除。在这种情况下，如果终止一个worker，它正在处理的消息将丢失。发送给此特定worker但尚未处理的消息也会丢失。</p><p>如果RabbitMQ没有收到消费者的消息确认，会对这个消息进行重新排队。</p><blockquote><p>思考：如何重新排队</p></blockquote><p>超时时间：</p><p><code>channel.basicPublish(&quot;&quot;, routingKey, null, json.getBytes());</code></p><p>第一个参数：交换器名称</p><p>消息如何传递： 生产者---交换器---队列---消费者</p>',8)]))}const m=t(i,[["render",n]]);export{b as __pageData,m as default};
