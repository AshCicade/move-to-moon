import{_ as i,c as a,a1 as t,o as n}from"./chunks/framework.CtAjElTc.js";const o=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guides/xml/XML解析.md","filePath":"guides/xml/XML解析.md"}'),l={name:"guides/xml/XML解析.md"};function e(h,s,p,k,r,E){return n(),a("div",null,s[0]||(s[0]=[t(`<h2 id="dom解析方法" tabindex="-1">DOM解析方法 <a class="header-anchor" href="#dom解析方法" aria-label="Permalink to &quot;DOM解析方法&quot;">​</a></h2><p>DOM，文档对象模型(Document Object Model)，是官方推荐的标准。DOM是html和xml文档的编程接口规范，和平台、语言是无关的。利用DOM规范，能够实现DOM 文档和xml之间的相互转换，遍历、操作相应DOM文档的内容。DOM规范的核心就是树模型，全部读取之后再解析。</p><p>原理是：首先在内存中创建一个Document对象，然后把XML文档读取进来赋值给这个dom对象。由于dom对象是基于树结构的，所以对dom对象进行遍历即可。对内存中的dom对象可以进行查询、修改、删除操作，还可以写回原XML文档保存修改。</p><p>优点：由于整棵树在内存中，因此可以对xml文档随机访问；可以对xml文档进行修改操作 缺点：整个文档必须一次性解析完；由于整个文档都需要载入内存，当XML文件较大的时候，对内存耗费比较大，容易影响解析性能并且可能会造成内存溢出。</p><h3 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javax.xml.parsers.DocumentBuilder;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> javax.xml.parsers.DocumentBuilderFactory;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.w3c.dom.Document;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.w3c.dom.NodeList;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.xml.sax.InputSource;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.io.StringReader;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DomExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        String xml </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&lt;root&gt;&lt;item id=&#39;1&#39;&gt;Text1&lt;/item&gt;&lt;item id=&#39;2&#39;&gt;Text2&lt;/item&gt;&lt;/root&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DocumentBuilderFactory factory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DocumentBuilderFactory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DocumentBuilder builder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> factory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newDocumentBuilder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Document doc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> builder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> InputSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringReader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xml)));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        NodeList itemList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> doc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> itemList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getLength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(itemList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTextContent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="sax解析方法" tabindex="-1">SAX解析方法 <a class="header-anchor" href="#sax解析方法" aria-label="Permalink to &quot;SAX解析方法&quot;">​</a></h2><p>SAX，简单应用程序接口(Simple Api For Xml)。非W3C官方所提供的标准，是一个程序员社区研究出来。SAX在概念上与DOM完全不同。非文档驱动，是事件驱动的。事件驱动：一种基于回调机制的程序运行方法。由外至内一层一层解析。</p><p>优点：解析速度快，占用内存少，它需要哪些数据再加载和解析哪些内容。</p><p>缺点：它不会记录标签的关系，而是需要应用程序自己处理，这样就会增加程序的负担。</p><h3 id="代码实现-1" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现-1" aria-label="Permalink to &quot;代码实现&quot;">​</a></h3><h2 id="jdom解析方法" tabindex="-1">JDOM解析方法 <a class="header-anchor" href="#jdom解析方法" aria-label="Permalink to &quot;JDOM解析方法&quot;">​</a></h2><p>JDOM是Java和DOM的结合体。JDOM 致力于建立一个完整的基于 Java 平台的、通过 Java 代码来访问、操作并输出 XML 数据。JDOM是用Java语言读、写、操作XML的新API函数。简单、高效、优化。</p><p>优点：查找方便，可以修改</p><p>缺点：装载整个文档,对内存容量要求高</p><h2 id="dom4j解析方法" tabindex="-1">DOM4J解析方法 <a class="header-anchor" href="#dom4j解析方法" aria-label="Permalink to &quot;DOM4J解析方法&quot;">​</a></h2><p>dom4j是一个Java的XML API，类似于jdom，用来读写XML文件的。性能优异功能强大简单易用开放源代码。它是目前最流行、最好用的XML解析工具，解析XML的速度最快。</p><p>操作步骤：</p><ol><li>创建SAXReader：SAXReader reader = new SAXReader();</li><li>创建文件输入流打开xml文件：InputStream in = new FileInputStream(&quot;XXX.xml&quot;);</li><li>通过reader和输入流读取xml文件到内存创建Document对象：Document dom = reader.read(in);</li><li>获取根节点：Element root=dom.getRootElement();</li><li>获取子节点列表：List childNodes = root.elements();</li><li>遍历子节点：Element node = childNodes.get(i);</li><li>读取结点信息： <ul><li>结点属性值：node.attributeValue(&quot;属性名&quot;)；</li><li>结点名：node.getName()；</li><li>结点值：node.getValue();</li><li>子结点文本值：node.elementText(&quot;子结点名&quot;)</li></ul></li></ol>`,19)]))}const g=i(l,[["render",e]]);export{o as __pageData,g as default};
